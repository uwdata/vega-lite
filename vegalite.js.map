{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl.js","src/Encoding.js","src/axis.js","src/scale.js"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vegalite.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var vl = {\n  Encoding: require('./Encoding'),\n  axis: require('./axis'),\n  scale: require('./scale'),\n  // schema: require('./schema')\n\n};\n\nglobal.TABLE = \"table\";\nglobal.STACKED = \"stacked\";\nglobal.INDEX = \"index\";\n\nglobal.X = \"x\";\nglobal.Y = \"y\";\nglobal.ROW = \"row\";\nglobal.COL = \"col\";\nglobal.SIZE = \"size\";\nglobal.SHAPE = \"shape\";\nglobal.COLOR = \"color\";\nglobal.ALPHA = \"alpha\";\nglobal.TEXT = \"text\";\n\nglobal.O = 1;\nglobal.Q = 2;\nglobal.T = 4;\n\nvl.encodings = {X:X, Y:Y, ROW:ROW, COL:COL, SIZE:SIZE, SHAPE:SHAPE, COLOR:COLOR, ALPHA:ALPHA, TEXT:TEXT};\n\nvl.dataTypes = {\"O\": O, \"Q\": Q, \"T\": T};\n\n// inverse mapping e.g., 1=>O\nvl.dataTypeNames = [\"O\",\"Q\",\"T\"].reduce(function(r,x) {\n  r[vl.dataTypes[x]] = x; return r;\n},{});\n\n\n// vl.schema.aggr.enum\nvl.quantAggTypes = [\"avg\", \"sum\", \"min\", \"max\", \"count\"];\n\n// vl.schema.timefns\nvl.timeFuncs = [\"month\", \"year\", \"day\", \"date\", \"hour\", \"minute\", \"second\"];\n// vl.schema.scale_type.enum\nvl.quantScales = [\"-\", \"log\",\"pow\", \"sqrt\", \"quantile\"];\n\nvl.DEFAULTS = {\n  // template\n  width: undefined,\n  height: undefined,\n  viewport: undefined,\n  _minWidth: 20,\n  _minHeight: 20,\n\n  // data source\n  dataUrl: undefined, //for easier export\n  useVegaServer: false,\n  vegaServerUrl: \"http://localhost:3001\",\n  vegaServerTable: undefined,\n  dataFormatType: \"json\",\n\n  //small multiples\n  cellHeight: 200, // will be overwritten by bandWidth\n  cellWidth: 200, // will be overwritten by bandWidth\n  cellPadding: 0.1,\n  cellBackgroundColor: \"#fdfdfd\",\n  xAxisMargin: 80,\n  yAxisMargin: 0,\n  textCellWidth: 90,\n\n  // marks\n  bandSize: 21,\n  bandPadding: 1,\n  pointSize: 50,\n  pointShape: \"circle\",\n  strokeWidth: 2,\n  color: \"steelblue\",\n  textColor: \"black\",\n  textAlign: \"left\",\n  textBaseline: \"middle\",\n  textMargin: 4,\n  font: \"Helvetica Neue\",\n  fontSize: \"12\",\n  fontWeight: \"normal\",\n  fontStyle: \"normal\",\n  opacity: 1,\n  _thickOpacity: 0.5,\n  _thinOpacity: 0.2,\n\n  // scales\n  // TODO remove _xZero, ...\n  _xZero: true,\n  _xReverse: false,\n  _yZero: true,\n  _yReverse: false,\n  timeScaleNice: \"day\"\n};\n\n\nvl.keys = function (obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n}\n\nvl.vals = function (obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n}\n\nvl.duplicate = function (obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nvl.any = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(f(arr[k], k, i++)) return true;\n  }\n  return false;\n}\n\nvl.all = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(!f(arr[k], k, i++)) return false;\n  }\n  return true;\n}\n\nvl.merge = function(dest, src){\n  return vl.keys(src).reduce(function(c, k){\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nvl.error = function(msg){\n  console.error(\"[VL Error]\", msg);\n}\n\nmodule.exports = vl;","module.exports = (function() {\n\n  function Encoding(marktype, enc, config) {\n    this._marktype = marktype;\n    this._enc = enc; // {encType1:field1, ...}\n\n    this._cfg = vl.merge(Object.create(vl.DEFAULTS), config);\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(x) {\n    return this._enc[x] !== undefined;\n  };\n\n  proto.enc = function(x){\n    return this._enc[x];\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(x, nodata, nofn) {\n    if (!this.has(x)) return null;\n\n    var f = (nodata ? \"\" : \"data.\");\n\n    if (this._enc[x].aggr === \"count\") {\n      return f + \"count\";\n    } else if (!nofn && this._enc[x].bin) {\n      return f + \"bin_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].aggr) {\n      return f + this._enc[x].aggr + \"_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].fn){\n      return f + this._enc[x].fn + \"_\" + this._enc[x].name;\n    } else {\n      return f + this._enc[x].name;\n    }\n  };\n\n  proto.fieldName = function(x){\n    return this._enc[x].name;\n  }\n\n  proto.scale = function(x){\n    return this._enc[x].scale || {};\n  }\n\n  proto.aggr = function(x){\n    return this._enc[x].aggr;\n  }\n\n  proto.bin = function(x){\n    return this._enc[x].bin;\n  }\n\n  proto.fn = function(x){\n    return this._enc[x].fn;\n  }\n\n  proto.any = function(f){\n    return vl.any(this._enc, f);\n  }\n\n  proto.all = function(f){\n    return vl.all(this._enc, f);\n  }\n\n  proto.length = function(){\n    return vl.keys(this._enc).length;\n  }\n\n  proto.reduce = function(f, init){\n    var r = init, i=0;\n    for (k in this._enc){\n      r = f(r, this._enc[k], k, this._enc);\n    }\n    return r;\n  }\n\n  proto.forEach = function(f) {\n    var i=0, k;\n    for (k in this._enc) {\n      f(k, this._enc[k], i++);\n    }\n  };\n\n  proto.type = function(x) {\n    return this.has(x) ? this._enc[x].type : null;\n  };\n\n  proto.isType = function(x, t) {\n    var xt = this.type(x);\n    if (xt == null) return false;\n    return (xt & t) > 0;\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toJSON = function(space, excludeConfig){\n    var enc = vl.duplicate(this._enc), json;\n\n    // convert type's bitcode to type name\n    for(var e in enc){\n      enc[e].type = vl.dataTypeNames[enc[e].type];\n    }\n\n    json = {\n      marktype: this._marktype,\n      enc: enc\n    }\n\n    if(!excludeConfig){\n      json.cfg = vl.duplicate(this._cfg)\n    }\n\n    return json;\n  };\n\n  proto.toShorthand = function(){\n    var enc = this._enc;\n    return this._marktype + \".\" + vl.keys(enc).map(function(e){\n      var v = enc[e];\n        return e + \"-\" +\n          (v.aggr ? v.aggr+\"_\" : \"\") +\n          (v.fn ? v.fn+\"_\" : \"\") +\n          (v.bin ? \"bin_\" : \"\") +\n          (v.name || \"\") + \"-\" +\n          vl.dataTypeNames[v.type];\n      }\n    ).join(\".\");\n  }\n\n  Encoding.parseShorthand = function(shorthand, cfg){\n    var enc = shorthand.split(\".\"),\n      marktype = enc.shift();\n\n    enc = enc.reduce(function(m, e){\n      var split = e.split(\"-\"),\n        enctype = split[0],\n        o = {name: split[1], type: vl.dataTypes[split[2]]};\n\n      // check aggregate type\n      for(var i in vl.quantAggTypes){\n        var a = vl.quantAggTypes[i];\n        if(o.name.indexOf(a+\"_\") == 0){\n          o.name = o.name.substr(a.length+1);\n          if (a==\"count\" && o.name.length === 0) o.name = \"*\";\n          o.aggr = a;\n          break;\n        }\n      }\n      // check time fn\n      for(var i in vl.timeFuncs){\n        var f = vl.timeFuncs[i];\n        if(o.name && o.name.indexOf(f+\"_\") == 0){\n          o.name = o.name.substr(o.length+1);\n          o.fn = f;\n          break;\n        }\n      }\n\n      // check bin\n      if(o.name && o.name.indexOf(\"bin_\") == 0){\n        o.name = o.name.substr(4);\n        o.bin = true;\n      }\n\n      m[enctype] = o;\n      return m;\n    }, {});\n\n    return new Encoding(marktype, enc, cfg);\n  }\n\n  Encoding.parseJSON = function(json, extraCfg) {\n    var enc = vl.duplicate(json.enc);\n\n    //convert type from string to bitcode (e.g, O=1)\n    for(var e in enc){\n      enc[e].type = vl.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(json.marktype, enc, vl.merge(json.cfg, extraCfg || {}));\n  }\n\n  return Encoding;\n\n})();","var axis = module.exports;\n\naxis.defs = function(names, encoding, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis_def(name, encoding, opt));\n    return a;\n  }, []);\n}\n\naxis.names = function (props) {\n  return vl.keys(vl.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s===X || s===Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\nfunction axis_def(name, encoding, opt){\n  var type = name, axis;\n  var isCol = name==COL, isRow = name==ROW;\n  if(isCol) type = \"x\";\n  if(isRow) type = \"y\";\n\n  var axis = {\n    type: type,\n    scale: name,\n    ticks: 3 //TODO(kanitw): better determine # of ticks\n  };\n\n  if(isRow || isCol){\n    axis.properties = {\n      ticks: { opacity: {value: 0} },\n      majorTicks: { opacity: {value: 0} },\n      axis: { opacity: {value: 0} }\n    };\n  }\n  if(isCol){\n    axis.offset = [opt.xAxisMargin || 0, encoding.config(\"yAxisMargin\")];\n    axis.orient = \"top\";\n  }\n\n  if (name==\"x\" && (encoding.isType(name, O) || encoding.bin(name))) {\n    axis.properties = {\n      labels: {\n        angle: {value: 270},\n        align: {value: \"right\"},\n        baseline: {value: \"middle\"}\n      }\n    }\n  }\n\n  return axis;\n}\n","var vl = require('./vl');\n\nvar scale = module.exports;\n\nscale.names = function (props) {\n  return vl.keys(vl.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\nscale.defs = function (names, encoding, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale_type(name, encoding),\n      domain: scale_domain(name, encoding, opt)\n    };\n    if (s.type === \"ordinal\") {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, opt);\n\n    return (a.push(s), a);\n  }, []);\n}\n\nfunction scale_type(name, encoding) {\n  switch (encoding.type(name)) {\n    case O: return \"ordinal\";\n    case T:\n      if (encoding.fn(name)) {\n        return \"linear\";\n      }\n      return \"time\";\n    case Q:\n      if (encoding.bin(name)) {\n        return \"ordinal\";\n      }\n      return encoding.scale(name).type || \"linear\";\n  }\n}\n\nfunction scale_domain(name, encoding, opt) {\n  if (encoding.type(name) === T){\n    switch(encoding.fn(name)){\n      case \"second\":\n      case \"minute\": return [0, 59];\n      case \"hour\": return [0, 23];\n      case \"day\": return [0, 6];\n      case \"date\": return [1, 31];\n      case \"month\": return [0, 11];\n    }\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = vg.data.bin().bins(opt.stats[encoding.fieldName(name)], {maxbins: 20});\n      var domain = [];\n      console.log(bins)\n      for (var i = bins.start; i < bins.stop; i+=bins.step) {\n        domain.push(i);\n      }\n      return domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: \"data.\" + (opt.facet ? \"max_\" :\"\") + \"sum_\" + encoding.field(name, true)\n    }:\n    {data: TABLE, field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellWidth ? [0, opt.cellWidth] : \"width\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_xZero\");\n        s.reverse = spec.reverse || encoding.config(\"_xReverse\");\n      }\n      s.round = true;\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellHeight ? [opt.cellHeight, 0] : \"height\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_yZero\");\n        s.reverse = spec.reverse || encoding.config(\"_yReverse\");\n      }\n\n      s.round = true;\n\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name);\n      }else{\n        s.nice = true;\n      }\n      break;\n    case ROW:\n      s.bandWidth = opt.cellHeight || encoding.config(\"cellHeight\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL:\n      s.bandWidth = opt.cellWidth || encoding.config(\"cellWidth\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is(\"bar\")) {\n        s.range = [3, +encoding.config(\"bandSize\")];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else {\n        s.range = [10, 1000];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = \"shapes\";\n      break;\n    case COLOR:\n      if (encoding.isType(s.name, O)) {\n        s.range = \"category10\";\n      } else {\n        s.range = [\"#ddf\", \"steelblue\"];\n        s.zero = false;\n      }\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error(\"Unknown encoding name: \"+s.name);\n  }\n\n  switch(s.name){\n    case ROW:\n    case COL:\n      s.padding = encoding.config(\"cellPadding\");\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name) ) { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.config(\"bandPadding\");\n      }\n  }\n}"]}